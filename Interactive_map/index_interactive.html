<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Thessalia Cartography â€“ Interactive Map</title>
<meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />

<!-- ============================================================
     EXTERNAL LIBRARIES - MAPLIBRE GL
     ============================================================
     MapLibre GL is an open-source library for displaying interactive maps
     We need both the CSS (for styling) and JavaScript (for functionality)
     ============================================================ -->

<!--
MapLibre GL CSS
- Provides the visual styling for the map
- Styles map controls (zoom buttons, attribution, scale bar)
- Ensures correct layout and appearance of the map canvas
-->
<link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />

<!--
MapLibre GL JavaScript
- Core MapLibre library for web mapping
- Handles map rendering using WebGL
- Enables interaction (zoom, pan, rotation)
- Supports loading layers, GeoJSON data, and user events
-->
<script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>

<!-- ============================================================
     CSS STYLING SECTION
     ============================================================
     This <style> section contains all the visual styling rules for:
     - Map container layout
     - Control panels (left side)
     - Legend (top right) 
     - Buttons, sliders, and other UI elements
     
     You generally don't need to modify CSS unless you want
     to change the appearance of the interface itself
     ============================================================ -->
<style>
  body { margin: 0; padding: 0; font-family: Arial, Helvetica, sans-serif; }
  #map { position: absolute; top: 0; bottom: 0; width: 100%; }

  #styleSelector {
    position: absolute;
    top: 10px;
    left: 10px;
    z-index: 6;
    background: white;
    padding: 6px;
    border-radius: 4px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.25);
  }

  #controls {
    position: absolute;
    top: 60px;
    left: 10px;
    z-index: 6;
    background: white;
    padding: 10px;
    font-size: 13px;
    border-radius: 6px;
    width: 300px;
    max-height: 80vh;
    overflow-y: auto;
    box-shadow: 0 2px 6px rgba(0,0,0,0.25);
  }
  .layer-controls { margin-top:6px; padding:8px; background:#fafafa; border-radius:4px; display:none; }
  .layer-controls label { display:block; font-size:12px; margin-top:6px; }
  .layer-controls input[type="range"], .layer-controls select { width:100%; margin-top:4px; }

  #legend {
    position: absolute;
    top: 10px;
    right: 10px;
    z-index: 6;
    background: white;
    padding: 18px;
    font-size: 13px;
    border-radius: 6px;
    max-width: 360px; /* ğŸ—ºï¸ Allows user to change the legend box max width */
    max-height: 85vh; /* ğŸ—ºï¸ Allows user to change the legend box max height */
    box-shadow: 0 2px 6px rgba(0,0,0,0.25);
    display: none;
    resize: both;
    overflow: auto;
    min-width: 200px; /* ğŸ—ºï¸ Allows user to change the legend box min width */
    min-height: 100px; /* ğŸ—ºï¸ Allows user to change the legend box min height */
  }
  
  /* ğŸŒ ğŸ—ºï¸ MODIFY HEADER STYLES: Change title/subtitle/author font sizes and colors here */
  .legend-header {
    margin-bottom: 16px;
    padding-bottom: 12px;
    border-bottom: 2px solid #333;
  }
  .legend-map-title {
    font-size: 17px; /* ğŸŒ Adjust size for main title */
    font-weight: 700;
    color: #000; /* ğŸ—ºï¸ Change hex code for different title color */
    margin-bottom: 10px;
    line-height: 1.4;
    text-align: center;
  }
  .legend-subtitle {
    font-size: 10px; /* ğŸ—ºï¸ Adjust size for subtitle */
    font-style: italic;
    color: #333; /* ğŸ—ºï¸ Change subtitle color */
    margin-bottom: 10px;
    line-height: 1.3;
    text-align: center;
  }
  .legend-author {
    font-size: 12px; /* ğŸŒ Adjust size for author information */
    color: #555; /* ğŸ—ºï¸ Change author text color */
    line-height: 1.4;
    text-align: left;
  }
  .legend-author strong {
    font-weight: 700;
  }
  
  .legend-row { display:flex; align-items:center; margin-bottom:8px; }
  .legend-color { width:20px; height:20px; margin-right:8px; border-radius:3px; flex:none; }
  .legend-line { width:40px; height:14px; margin-right:8px; flex:none; }
  .legend-title { font-weight:700; margin-bottom:8px; display:block; }
  .control-value { font-weight:700; margin-left:6px; color:#333; }
  hr { border: none; border-top: 1px solid #eee; margin:8px 0; }
</style>
<!-- ============================================================
     END OF CSS STYLING SECTION
     ============================================================ -->
</head>
<body>

<!-- ============================================================
     HTML STRUCTURE SECTION - USER INTERFACE ELEMENTS
     ============================================================
     This section defines the visual interface that users interact with:
     - Basemap selector (Light/Dark)
     - Layer checkboxes and controls (left panel)
     - Legend (right panel, dynamically updated by JavaScript)
     - Map container (fills the entire background)
     ============================================================ -->

<!-- BASEMAP SELECTOR (Top-left corner) -->
<!-- ğŸŒ When you change a basemap (the link) you should also change the name of the basemap you select (i.e., Light, Dark) inside the >...< -->
<!-- Allows user to switch between Light and Dark background maps -->
<div id="styleSelector">
  <select id="basemapSelect">
    <option value="https://basemaps.cartocdn.com/gl/positron-gl-style/style.json">Light / Î¦Ï‰Ï„ÎµÎ¹Î½ÏŒ</option>
    <option value="https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json" selected>Dark / Î£ÎºÎ¿Ï„ÎµÎ¹Î½ÏŒ</option>
    <option value="https://tiles.openfreemap.org/styles/liberty">Liberty / Î¡ÎµÎ±Î»Î¹ÏƒÏ„Î¹ÎºÏŒ</option>
  </select>
</div>

<!-- ğŸ—ºï¸ Add more basemap options like this:
<option value="URL_TO_BASEMAP_STYLE">Your Basemap Name</option>
Examples:
- OpenStreetMap: https://tiles.openfreemap.org/styles/liberty
-->

<!-- Layer controls panel (left side of screen) -->
<!-- ğŸŒ You can change the layer names shown to users by editing the <strong> text below -->
<div id="controls">
  <strong>Layers / Î˜ÎµÎ¼Î±Ï„Î¹ÎºÎ¬ ÎµÏ€Î¯Ï€ÎµÎ´Î±</strong><br><br>

  <!-- Layer 1: Population Density Choropleth Map -->
  <!-- ğŸ—ºï¸ Change "Population Density (Choropleth Map)" to your preferred layer name (Line 174)-->
  <input type="checkbox" id="popdensToggle"> <strong>Population Density (Choropleth Map) / Î Ï…ÎºÎ½ÏŒÏ„Î·Ï„Î± Ï€Î»Î·Î¸Ï…ÏƒÎ¼Î¿Ï (Î§Ï‰ÏÎ¿Ï€Î»Î·Î¸Î®Ï‚ Ï‡Î¬ÏÏ„Î·Ï‚)</strong><br>
  <div class="layer-controls" id="popdensControls">
    <label>Classification method / ÎœÎ­Î¸Î¿Î´Î¿Ï‚ Ï„Î±Î¾Î¹Î½ÏŒÎ¼Î·ÏƒÎ·Ï‚:
      <select id="classificationMethod">
        <option value="equal" selected>Equal interval (default) / ÎŠÏƒÎ± Î´Î¹Î±ÏƒÏ„Î®Î¼Î±Ï„Î± (Ï€ÏÎ¿ÎµÏ€Î¹Î»Î¿Î³Î®)</option>
        <option value="quantile">Quantiles / Î Î¿ÏƒÎ¿ÏƒÏ„Î¬</option>
        <option value="natural">Natural breaks (Jenks) Î¦Ï…ÏƒÎ¹ÎºÎ¬ Î´Î¹Î±ÏƒÏ„Î®Î¼Î±Ï„Î± (Î¤Î¶ÎµÎ½ÎºÏ‚)</option>
        <option value="custom">Custom intervals / Î ÏÎ¿ÏƒÎ±ÏÎ¼Î¿ÏƒÎ¼Î­Î½Î± Î´Î¹Î±ÏƒÏ„Î®Î¼Î±Ï„Î±</option>
      </select>
    </label>
    <label id="numClassesLabel">Number of classes / Î‘ÏÎ¹Î¸Î¼ÏŒÏ‚ ÎºÎ»Î¬ÏƒÎµÏ‰Î½:
      <select id="numClasses">
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5" selected>5</option>
        <option value="6">6</option>
        <option value="7">7</option>
      </select>
    </label>
    <label>Opacity / Î”Î¹Î±Ï†Î¬Î½ÎµÎ¹Î±: <span id="popdensOpacityLabel" class="control-value">60%</span>
      <input type="range" id="popdensOpacity" min="0" max="100" value="60">
    </label>
  </div>
  <hr>

  <!-- Layer 2: Population Density Dasymmetric Map -->
  <!-- ğŸ—ºï¸ Change "Population Density (Dasymmetric Map)" to your preferred layer name (Line 201)-->
  <input type="checkbox" id="denscoverToggle"> <strong>Population Density (Dasymmetric Map) / Î Ï…ÎºÎ½ÏŒÏ„Î·Ï„Î± Ï€Î»Î·Î¸Ï…ÏƒÎ¼Î¿Ï (Î”Î±ÏƒÏ…Î¼ÎµÏ„ÏÎ¹ÎºÏŒÏ‚ Ï‡Î¬ÏÏ„Î·Ï‚)</strong><br>
  <div class="layer-controls" id="denscoverControls">
    <label>Classification method / ÎœÎ­Î¸Î¿Î´Î¿Ï‚ Ï„Î±Î¾Î¹Î½ÏŒÎ¼Î·ÏƒÎ·Ï‚:
      <select id="denscoverClassificationMethod">
        <option value="equal" selected>Equal interval (default) / ÎŠÏƒÎ± Î´Î¹Î±ÏƒÏ„Î®Î¼Î±Ï„Î± (Ï€ÏÎ¿ÎµÏ€Î¹Î»Î¿Î³Î®)</option>
        <option value="quantile">Quantiles / Î Î¿ÏƒÎ¿ÏƒÏ„Î¬</option>
        <option value="natural">Natural breaks (Jenks) Î¦Ï…ÏƒÎ¹ÎºÎ¬ Î´Î¹Î±ÏƒÏ„Î®Î¼Î±Ï„Î± (Î¤Î¶ÎµÎ½ÎºÏ‚)</option>
        <option value="custom">Custom intervals / Î ÏÎ¿ÏƒÎ±ÏÎ¼Î¿ÏƒÎ¼Î­Î½Î± Î´Î¹Î±ÏƒÏ„Î®Î¼Î±Ï„Î±</option>
      </select>
    </label>
    <label id="denscoverNumClassesLabel">ber of classes / Î‘ÏÎ¹Î¸Î¼ÏŒÏ‚ ÎºÎ»Î¬ÏƒÎµÏ‰Î½:
      <select id="denscoverNumClasses">
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5" selected>5</option>
        <option value="6">6</option>
        <option value="7">7</option>
      </select>
    </label>
    <label>Opacity / Î”Î¹Î±Ï†Î¬Î½ÎµÎ¹Î±: <span id="denscoverOpacityLabel" class="control-value">60%</span>
      <input type="range" id="denscoverOpacity" min="0" max="100" value="60">
    </label>
  </div>
  <hr>

  <!-- Layer 3: Population Proportional Symbols -->
  <!-- ğŸ—ºï¸ Change "Population (Proportional symbols)" to your preferred layer name (Line 228)-->
  <input type="checkbox" id="poipopToggle"> <strong>Population (Proportional symbols) / Î Î»Î·Î¸Ï…ÏƒÎ¼ÏŒÏ‚ (Î‘Î½Î±Î»Î¿Î³Î¹ÎºÎ¬ ÏƒÏÎ¼Î²Î¿Î»Î±)</strong><br>
  <div class="layer-controls" id="poipopControls">
    <label>Maximum circle radius (px) / ÎœÎ­Î³Î¹ÏƒÏ„Î· Î±ÎºÏ„Î¯Î½Î± ÎºÏÎºÎ»Î¿Ï… (Ï€Î¯Î¾ÎµÎ»Ï‚): <span id="maxRadiusLabel" class="control-value">100</span>
      <input type="range" id="maxRadius" min="20" max="200" value="100">
    </label>
    <label>Opacity (circles) Î”Î¹Î±Ï†Î¬Î½ÎµÎ¹Î± (ÎºÏÎºÎ»Î¿Î¹): <span id="poipopOpacityLabel" class="control-value">50%</span>
      <input type="range" id="poipopOpacity" min="0" max="100" value="50">
    </label>
    <small style="display:block;margin-top:6px;color:#555">
      <strong>Note:</strong> Flannery scaling is used for perceptual equality.
    </small>
      <small style="display:block;margin-top:6px;color:#555">
      <strong>Î£Î·Î¼ÎµÎ¯Ï‰ÏƒÎ·:</strong> Î§ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯Ï„Î±Î¹ Î· Î´Î¹ÏŒÏÎ¸Ï‰ÏƒÎ· Flannery Î³Î¹Î± Î±Î½Ï„Î¹Î»Î·Ï€Ï„Î¹ÎºÎ® Î¹ÏƒÏŒÏ„Î·Ï„Î±.
    </small>
  </div>
  <hr>

  <!-- Layer 4: Population Dynamic Contours (Isopleths) -->
  <!-- ğŸŒ Change "Population dynamic (Isopleths map)" to your preferred layer name (Line 244)-->
  <input type="checkbox" id="contoursToggle"> <strong>Population dynamic (Isopleths map) / Î”Ï…Î½Î±Î¼Î¹ÎºÏŒ Ï€Î»Î·Î¸Ï…ÏƒÎ¼Î¿Ï (Î™ÏƒÎ¿Ï€Î»Î·Î¸Î®Ï‚ Ï‡Î¬ÏÏ„Î·Ï‚)</strong><br>
  <div class="layer-controls" id="contoursControls">
    <label>Opacity (contours) / Î”Î¹Î±Ï†Î¬Î½ÎµÎ¹Î± (ÎºÎ±Î¼Ï€ÏÎ»ÎµÏ‚): <span id="contoursOpacityLabel" class="control-value">100%</span>
      <input type="range" id="contoursOpacity" min="0" max="100" value="100">
    </label>
  </div>
  <hr>

  <!-- Layer 5: Population Dot Map -->
  <!-- ğŸŒ Change "Population (Dot map)" to your preferred layer name (Line 254)-->
  <input type="checkbox" id="dotsToggle"> <strong>Population (Dot map) / Î Î»Î·Î¸Ï…ÏƒÎ¼ÏŒÏ‚ (Î§Î¬ÏÏ„Î·Ï‚ ÎºÎ¿Ï…ÎºÎ¯Î´Ï‰Î½)</strong><br>
  <div class="layer-controls" id="dotsControls">
    <label>Dot size (px) / ÎœÎ­Î³ÎµÎ¸Î¿Ï‚ ÎºÎ¿Ï…ÎºÎ¯Î´Î±Ï‚ (Ï€Î¯Î¾ÎµÎ»Ï‚): <span id="dotSizeLabel" class="control-value">2.0</span>
      <input type="range" id="dotSize" min="0.5" max="6" step="0.1" value="2.0">
    </label>
    <label>Opacity (dots) / Î”Î¹Î±Ï†Î¬Î½ÎµÎ¹Î± (Ï€Î¯Î¾ÎµÎ»Ï‚): <span id="dotsOpacityLabel" class="control-value">100%</span>
      <input type="range" id="dotsOpacity" min="0" max="100" value="100">
    </label>
  </div>
  <hr>

  <!-- Layer 6: Municipal Boundaries -->
  <!-- ğŸŒ Change "Municipal boundaries" to your preferred layer name (Line 267)-->
  <input type="checkbox" id="boundariesToggle"> <strong>Municipal boundaries / ÎŒÏÎ¹Î± Î´Î®Î¼Ï‰Î½</strong><br>
  <div class="layer-controls" id="boundariesControls">
    <label>Opacity (boundaries) / Î”Î¹Î±Ï†Î¬Î½ÎµÎ¹Î± (ÏŒÏÎ¹Î±): <span id="boundariesOpacityLabel" class="control-value">100%</span>
      <input type="range" id="boundariesOpacity" min="0" max="100" value="100">
    </label>
  </div>
  <hr>

  <!-- Data notes -->
  <!-- You may change here the caption on the bottom of the Layers window (Lines 279 - 280) -->
  <div style="font-size:12px;color:#555">
    <strong>Data notes / Î£Î·Î¼ÎµÎ¹ÏÏƒÎµÎ¹Ï‚</strong><br>
    - All GeoJSONs expected in <code>interactive_map_data/</code> folder<br>
    - Fields: <code>DENSITY</code>, <code>density_po</code>, <code>POPMUN</code>, <code>ID</code>
  </div>
</div>

<!-- Legend container (right side, dynamically populated by JavaScript) -->
<div id="legend"></div>

<!-- Map container (fills entire background) -->
<div id="map"></div>

<!-- ============================================================
     END OF HTML STRUCTURE SECTION
     ============================================================ -->

<!-- ============================================================
     JAVASCRIPT SECTION - APPLICATION LOGIC
     ============================================================
     Everything between <script> and </script> tags is JavaScript code.
     
     This section is organized into the following parts:
     1. MAP INITIALIZATION - Creates the map object
     2. DATA CONFIGURATION - Define where data files are located
     3. COLOR SCHEMES - Define colors for visualizations
     4. CLASSIFICATION FUNCTIONS - Calculate class breaks for choropleth maps
     5. LAYER LOADING FUNCTIONS - Load and display each layer type
     6. LEGEND GENERATION - Creates dynamic legend based on active layers
     7. EVENT LISTENERS - Responds to user interactions
     
     Focus on sections marked with ğŸŒ (mandatory changes)
     and ğŸ—ºï¸ (optional styling changes)
     ============================================================ -->
<script>

// ============================================================
// 1. MAP INITIALIZATION
// ============================================================
// This creates the interactive map object that will display everything

/**
* ğŸŒ Change center coordinates and zoom level for your study area
* 
* center: [longitude, latitude]
* - Longitude: -180 to 180 (negative = west, positive = east)
* - Latitude: -90 to 90 (negative = south, positive = north)
* 
* zoom: 0 to 20
* - 0 = entire world visible
* - 10 = city level
* - 15 = neighborhood level
* - 20 = building level
* 
* How to find coordinates:
* 1. Go to Google Maps
* 2. Right-click on your study area
* 3. Click on the coordinates that appear
* 4. Copy the numbers (latitude, longitude)
* 5. Swap them to (longitude, latitude) for MapLibre
*/

/* ğŸŒ MODIFY MAP CENTER AND ZOOM */
const map = new maplibregl.Map({
  container: 'map',           // Links to the <div id="map"> element in HTML
  style: 'https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json',  // Initial basemap style
  center: [22.3, 39.6],       // ğŸŒ [longitude, latitude] - CHANGE THIS TO MATCH THE STUDY AREA CENTER (APPROXIMATELY)!
  zoom: 8                    // ğŸŒ Initial zoom level - CHANGE THIS SO THAT THE REQUIRED ZOOM LEVEL ENCOMPASSES THE ENTIRE STUDY AREA. SMALLER VALUES - ZOOM OUT!
});

// ============================================================
// 2. DATA CONFIGURATION
// ============================================================
// This object defines where each GeoJSON file is located and which
// field contains the data to visualize

/**
* DATA_PATH: Location of your GeoJSON file with point data (population centroids)
* ğŸŒ Change this to point to YOUR data file
* 
* For local development:
*    - Use relative path like 'data/your_file.geojson'
*    - Make sure the file exists in that location
* 
* For GitHub Pages:
*    - Same relative path works (i.e. 'data/dimoi_poipop_WGS.geojson')
*    - Ensure file is committed to your repository
* 
* For external hosting:
*    - Use full URL like 'https://example.com/data/file.geojson'

/* ğŸŒ MODIFY DATA FILE PATHS AND FIELD NAMES */
const layerDefinitions = {
  // Choropleth map layer (population density by municipality)
  popdens: {
    sourceId: 'popdens-src',                       // Internal ID for the data source
    layerId: 'popdens-layer',                      // Internal ID for the map layer
    url: '/interactive_map_data/dimoi_density_wgs84.geojson',        // ğŸŒ Path to your file
    dataField: 'DENSITY'                           // ğŸŒ Column name in your GeoJSON
  },
  // Dasymmetric map layer (population density by land cover zone)
  denscover: {
    sourceId: 'denscover-src',
    layerId: 'denscover-layer',
    url: '/interactive_map_data/dasimetriki_cover_wgs84.geojson',  // ğŸŒ Path to your file
    dataField: 'density_po'                        // ğŸŒ Column name in your GeoJSON
  },
  // Proportional symbols layer (circles sized by population)
  poipop: {
    sourceId: 'poipop-src',
    layerId: 'poipop-layer',
    url: '/interactive_map_data/dimoi_pop_number.geojson',        // ğŸŒ Path to your file
    dataField: 'POPMUN',                           // ğŸŒ Column name in your GeoJSON
    maxValueApprox: 160000                         // ğŸŒ Set the maximum population value (for scaling circles)
  },
  // Contours / isopleths layer (population potential lines)
  contours: {
    sourceId: 'contours-src',
    layerId: 'contours-layer',
    url: '/interactive_map_data/contours_200_wgs84.geojson'     // ğŸŒ Path to your file
  },
  // Dot density layer (each dot represents X people)
  dots: {
    sourceId: 'dots-src',
    layerId: 'dots-layer',
    url: '/interactive_map_data/dots_500_wgs84.geojson'          // ğŸŒ Path to your file
  },
  // Boundaries layer (municipal borders)
  boundaries: {
    sourceId: 'boundaries-src',
    layerId: 'boundaries-layer',
    url: '/data_interactive/oria_dimoi_periferies_wgs_84.geojson'            // ğŸŒ Path to your file
  }
};

// Variables to cache loaded data (so we don't reload it every time)
let popdensData = null;      // Stores choropleth data once loaded
let denscoverData = null;    // Stores dasymmetric data once loaded

// Tracks which layers are currently visible on the map
const enabledLayers = { 
  popdens: false,
  denscover: false,
  poipop: false,
  contours: false,
  dots: false,
  boundaries: false
};

// ============================================================
// 3. COLOR SCHEMES
// ============================================================
// These arrays define the colors used for each classification method
// The number of colors must match the number of classes + 1

/* ğŸŒ MODIFY CHOROPLETH COLOR SCHEMES (for POPDENS layer) */
// ğŸ—ºï¸ Change these hex colors to customize your choropleth appearance
// IMPORTANT: Colors are automatically used in BOTH the map AND the legend
// - The legend generation code (Lines ~906-919) will automatically use these colors
// - You only need to change colors HERE - the legend updates automatically
// - Use hex format: '#RRGGBB' (e.g., '#ff0000' = red, '#0000ff' = blue, '#00ff00' = green)
// - Number of colors must equal number of classes
//
// ğŸ¨ HEX COLOR EXAMPLES:
// Red:     '#ff0000'  |  Blue:    '#0000ff'  |  Green:   '#00ff00'
// Orange:  '#ff8800'  |  Purple:  '#8800ff'  |  Magenta: '#ff00ff'
// Yellow:  '#ffff00'  |  Cyan:    '#00ffff'  |  Gray:    '#808080'
// Brown:   '#8B4513'  |  Pink:    '#ff69b4'  |  Teal:    '#008080'
//
// For sequential color schemes (light â†’ dark), use ColorBrewer: https://colorbrewer2.org/
// - Number of colors must equal number of classes
const colorSchemes = {
  3: ['#efedf5', '#bcbddc', '#756bb1'],           // ğŸŒ 3 classes = 3 colors (lightest to darkest)
  4: ['#f2f0f7', '#cbc9e2', '#9e9ac8', '#6a51a3'], // ğŸŒ 4 classes = 4 colors (lightest to darkest)
  5: ['#f2f0f7', '#cbc9e2', '#9e9ac8', '#756bb1', '#54278f'],  // Default ğŸŒ 5 classes = 5 colors (lightest to darkest)
  6: ['#f2f0f7', '#dadaeb', '#bcbddc', '#9e9ac8', '#756bb1', '#54278f'], // ğŸŒ 6 classes = 6 colors (lightest to darkest)
  7: ['#f2f0f7', '#dadaeb', '#bcbddc', '#9e9ac8', '#807dba', '#6a51a3', '#4a1486'] // ğŸŒ 7 classes = 7 colors (lightest to darkest)
};

/* ğŸŒ MODIFY DASYMMETRIC MAP COLOR SCHEMES (for DENS_COVER layer) */
// ğŸ—ºï¸ Change these hex colors (red scheme to match choropleth)
// IMPORTANT: Colors are automatically used in BOTH the map AND the legend
// - The legend generation code (Lines ~921-934) will automatically use these colors
/// - You only need to change colors HERE - the legend updates automatically
// - Use hex format: '#RRGGBB' (e.g., '#ff0000' = red, '#0000ff' = blue, '#00ff00' = green)
// - Number of colors must equal number of classes
//
// ğŸ¨ HEX COLOR EXAMPLES:
// Red:     '#ff0000'  |  Blue:    '#0000ff'  |  Green:   '#00ff00'
// Orange:  '#ff8800'  |  Purple:  '#8800ff'  |  Magenta: '#ff00ff'
// Yellow:  '#ffff00'  |  Cyan:    '#00ffff'  |  Gray:    '#808080'
// Brown:   '#8B4513'  |  Pink:    '#ff69b4'  |  Teal:    '#008080'
//
// For sequential color schemes (light â†’ dark), use ColorBrewer: https://colorbrewer2.org/
// - Number of colors must equal number of classes
const denscoverColorSchemes = {
  3: ['#efedf5', '#bcbddc', '#756bb1'],           // ğŸŒ 3 classes = 3 colors (lightest to darkest)
  4: ['#f2f0f7', '#cbc9e2', '#9e9ac8', '#6a51a3'], // ğŸŒ 4 classes = 4 colors (lightest to darkest)
  5: ['#f2f0f7', '#cbc9e2', '#9e9ac8', '#756bb1', '#54278f'],  // Default ğŸŒ 5 classes = 5 colors (lightest to darkest)
  6: ['#f2f0f7', '#dadaeb', '#bcbddc', '#9e9ac8', '#756bb1', '#54278f'], // ğŸŒ 6 classes = 6 colors (lightest to darkest)
  7: ['#f2f0f7', '#dadaeb', '#bcbddc', '#9e9ac8', '#807dba', '#6a51a3', '#4a1486'] // ğŸŒ 7 classes = 7 colors (lightest to darkest)
};

/* ğŸŒ DEFINE YOUR CUSTOM INTERVAL BREAKS FOR POPDENS */
// These break values define the class boundaries for custom classification
// IMPORTANT: The number of colors must equal number of breaks + 1
// Example: 5 breaks = 6 colors (one for each range: <break1, break1-break2, ..., >break5)
// 
// To change custom breaks:
// 1. Modify the values in customBreaks array below (Line ~490)
// 2. Modify the colors in customColors array below (Line ~491) - must have one more color than breaks
// 3. Select "Custom intervals" in classification dropdown
// 4. The legend (Lines ~906-919) will automatically update with your new breaks and colors
// 5. FOR THE CUSTOM INTERVALS, YOU DON'T HAVE TO ADD 3, 4 .... 7 CLASSES. IT'S UP TO YOU TO SELECT THE NUMBER OF CLASSES AND THE INTERVALS 
const customBreaks = [15, 20, 30, 90, 140, 490]; // ğŸŒ Set the custom class breaks
const customColors = ['#fcfbfd', '#efedf5', '#dadaeb', '#bcbddc', '#9e9ac8', '#807dba', '#6a51a3']; //ğŸŒ Set a colour for each class

/* ğŸŒ DEFINE YOUR CUSTOM INTERVAL BREAKS FOR DENS_COVER */
// These break values define the class boundaries for custom classification in dasymmetric map
// IMPORTANT: The number of colors must equal number of breaks + 1
// Example: 5 breaks = 6 colors (one for each range: <break1, break1-break2, ..., >break5)
// 
// To change custom breaks:
// 1. Modify the values in denscoverCustomBreaks array below (Line ~461)
// 2. Modify the colors in denscoverCustomColors array below (Line ~462) - must have one more color than breaks
// 3. Select "Custom intervals" in classification dropdown
// 4. The legend (Lines ~921-934) will automatically update with your new breaks and colors
// 5. FOR THE CUSTOM INTERVALS, YOU DON'T HAVE TO ADD 3, 4 .... 7 CLASSES. IT'S UP TO YOU TO SELECT THE NUMBER OF CLASSES AND THE INTERVALS 
const denscoverCustomBreaks = [4, 9, 16, 34, 581, 1410, 10400]; // ğŸŒ Set the custom class breaks
const denscoverCustomColors = ['#fcfbfd', '#efedf5', '#dadaeb', '#bcbddc', '#9e9ac8', '#807dba', '#6a51a3', '#4a1486']; //ğŸŒ Set a colour for each class

// ============================================================
// 4. CLASSIFICATION FUNCTIONS
// ============================================================
// These functions calculate class breaks for choropleth maps

/**
 * equalIntervalBreaks()
 * Divides the data range into equal-sized intervals
 * 
 * ğŸ“š BACKGROUND:
 * Equal interval classification divides the range of values into equal-sized bins.
 * For example, if values range from 0-100 and you want 5 classes, each class
 * will span 20 units (0-20, 20-40, 40-60, 60-80, 80-100).
 * 
 * PROS: Easy to understand, consistent intervals
 * CONS: May result in classes with very few or no features
 * 
 * @param {Array} sorted - Array of sorted numeric values
 * @param {number} n - Number of classes to create
 * @returns {Array} Array of break points
 */
function equalIntervalBreaks(sorted, n) {
  const min = sorted[0];
  const max = sorted[sorted.length-1];
  if (min === max) return [max];
  const step = (max - min) / n;
  const breaks = [];
  for (let i=1; i<n; i++) {
    breaks.push(min + step*i);
  }
  return breaks.map(b => Number(b.toFixed(2)));
}

/**
 * quantileBreaks()
 * Divides features into classes with equal numbers of features
 * 
 * ğŸ“š BACKGROUND:
 * Quantile classification ensures each class contains approximately
 * the same number of features/observations. If you have 100 municipalities and
 * want 5 classes, each class will contain about 20 municipalities.
 * 
 * PROS: Good for evenly distributed data, each class is well-represented
 * CONS: Can place very different values in the same class
 * 
 * @param {Array} sorted - Array of sorted numeric values
 * @param {number} n - Number of classes to create
 * @returns {Array} Array of break points
 */
function quantileBreaks(sorted, n) {
  const breaks = [];
  for (let i=1; i<n; i++){
    const idx = Math.floor((sorted.length * i)/n);
    breaks.push(sorted[Math.min(idx, sorted.length-1)]);
  }
  return breaks.map(b => Number(b.toFixed(2)));
}

/**
 * jenksBreaks()
 * Natural breaks (Jenks) - minimizes within-class variance
 * 
 * ğŸ“š BACKGROUND:
 * Jenks natural breaks algorithm identifies "natural" groupings in data
 * by minimizing variance within classes and maximizing variance between classes.
 * 
 * PROS: Identifies natural clusters in data, statistically optimal
 * CONS: More computationally intensive, not intuitive to explain
 * 
 * @param {Array} sorted - Array of sorted numeric values
 * @param {number} numClasses - Number of classes to create
 * @returns {Array} Array of break points
 */
function jenksBreaks(sorted, numClasses) {
  const n = sorted.length;
  const mat1 = Array.from({length: n+1}, () => Array(numClasses+1).fill(0));
  const mat2 = Array.from({length: n+1}, () => Array(numClasses+1).fill(0));

  for (let i=1; i<=numClasses; i++) {
    mat1[1][i] = 1;
    mat2[1][i] = 0;
    for (let j=2; j<=n; j++) {
      mat2[j][i] = Infinity;
    }
  }

  for (let l=2; l<=n; l++) {
    let s1=0, s2=0, w=0;
    for (let m=1; m<=l; m++) {
      const i3 = l - m + 1;
      const val = sorted[i3 - 1];
      s2 += val*val;
      s1 += val;
      w++;
      const v = s2 - (s1*s1)/w;
      const i4 = i3 - 1;
      if (i4 !== 0) {
        for (let j=2; j<=numClasses; j++){
          if (mat2[l][j] >= (v + mat2[i4][j-1])) {
            mat1[l][j] = i3;
            mat2[l][j] = v + mat2[i4][j-1];
          }
        }
      }
    }
    mat1[l][1] = 1;
    mat2[l][1] = mat2[l-1][1] + (sorted[l-1]-sorted[0])*(sorted[l-1]-sorted[0]);
  }

  const breaks = [];
  let k = n;
  for (let j = numClasses; j >= 2; j--) {
    const id = mat1[k][j] - 1;
    breaks.push(sorted[id]);
    k = mat1[k][j] - 1;
  }
  return breaks.reverse().map(b => Number(b.toFixed(2)));
}

/**
 * calculateBreaks()
 * Main function that calls the appropriate classification method
 * 
 * @param {Array} values - Array of values to classify
 * @param {number} numClasses - Number of classes
 * @param {string} method - Classification method ('equal', 'quantile', 'natural', 'custom')
 * @param {boolean} isCustom - Whether using custom breaks
 * @param {Array} customBreaksArray - Array of custom break values
 * @returns {Array} Array of break points
 */
function calculateBreaks(values, numClasses, method, isCustom, customBreaksArray) {
  const sorted = values.filter(v => v != null && !isNaN(v)).sort((a,b)=>a-b);
  if (sorted.length === 0) return [];
  if (method === 'equal') return equalIntervalBreaks(sorted, numClasses);
  if (method === 'quantile') return quantileBreaks(sorted, numClasses);
  if (method === 'natural') return jenksBreaks(sorted, numClasses);
  if (method === 'custom') return customBreaksArray;
  return equalIntervalBreaks(sorted, numClasses);
}

/**
 * createStepExpression()
 * Creates a MapLibre expression for coloring features based on class breaks
 * 
 * ğŸ“š BACKGROUND:
 * MapLibre uses expressions (array syntax) to define dynamic styling.
 * A 'step' expression acts like a lookup table: "if value < break1, use color1;
 * if value < break2, use color2; etc."
 * 
 * @param {Array} breaks - Array of break values
 * @param {Array} colors - Array of colors (length = breaks.length + 1)
 * @param {string} field - Field name to read values from
 * @returns {Array} MapLibre step expression
 */
function createStepExpression(breaks, colors, field) {
  const expr = ['step', ['get', field], colors[0]];
  for (let i=0; i<breaks.length; i++){
    expr.push(breaks[i]);
    expr.push(colors[i+1] || colors[colors.length-1]);
  }
  return expr;
}

/**
 * ensureSource()
 * Adds or updates a GeoJSON data source on the map
 * 
 * @param {string} id - Source ID
 * @param {string|object} urlOrGeojson - URL to fetch or GeoJSON object
 */
function ensureSource(id, urlOrGeojson) {
  if (!map.getSource(id)) {
    map.addSource(id, { type: 'geojson', data: urlOrGeojson });
  } else {
    if (typeof urlOrGeojson === 'object') {
      map.getSource(id).setData(urlOrGeojson);
    }
  }
}

// ============================================================
// 5. LAYER LOADING FUNCTIONS
// ============================================================
// These functions load and display each visualization layer

/**
 * applyPopDensClassification()
 * Applies the selected classification method to the choropleth layer
 * 
 * Process:
 * 1. Read user's selected classification method and number of classes
 * 2. Calculate appropriate breaks using the selected method
 * 3. Create color expression for MapLibre
 * 4. Add or update the layer on the map
 * 5. Update the legend to show the new classes
 */
function applyPopDensClassification() {
  if (!popdensData) {
    console.warn('No popdensData cached.');
    return;
  }
  
  const method = document.getElementById('classificationMethod').value;
  const nclasses = parseInt(document.getElementById('numClasses').value,10);
  
  let colors, breaks;
  
  if (method === 'custom') {
    breaks = customBreaks;
    colors = customColors;
  } else {
    colors = colorSchemes[nclasses] || colorSchemes[5];
    const values = popdensData.features.map(f => parseFloat(f.properties[layerDefinitions.popdens.dataField]));
    breaks = calculateBreaks(values, nclasses, method, false, null);
  }

  const expr = createStepExpression(breaks, colors, layerDefinitions.popdens.dataField);
  ensureSource(layerDefinitions.popdens.sourceId, popdensData);

  if (map.getLayer(layerDefinitions.popdens.layerId)) {
    map.setPaintProperty(layerDefinitions.popdens.layerId, 'fill-color', expr);
  } else {
    map.addLayer({
      id: layerDefinitions.popdens.layerId,
      type: 'fill',
      source: layerDefinitions.popdens.sourceId,
      paint: {
        'fill-color': expr,
        'fill-opacity': parseInt(document.getElementById('popdensOpacity').value,10)/100
      }
    });
  }

  layerDefinitions.popdens.breaks = breaks;
  layerDefinitions.popdens.colors = colors;
  enabledLayers.popdens = true;
  document.getElementById('popdensControls').style.display = 'block';
  updateLegend();
}

/**
 * loadPopDensLayer()
 * Fetches the choropleth GeoJSON file and applies classification
 */
function loadPopDensLayer() {
  fetch(layerDefinitions.popdens.url)
    .then(r => r.json())
    .then(gj => {
      popdensData = gj;
      applyPopDensClassification();
    })
    .catch(err => {
      console.error('Failed to load POPDENS:', err);
      alert('Error loading POPDENS geojson.');
    });
}

/**
 * applyDensCoverClassification()
 * Applies classification to the dasymmetric layer
 * 
 * Similar to applyPopDensClassification but for the dasymmetric map
 */
function applyDensCoverClassification() {
  if (!denscoverData) {
    console.warn('No denscoverData cached.');
    return;
  }
  
  const method = document.getElementById('denscoverClassificationMethod').value;
  const nclasses = parseInt(document.getElementById('denscoverNumClasses').value,10);
  
  let colors, breaks;
  
  if (method === 'custom') {
    breaks = denscoverCustomBreaks;
    colors = denscoverCustomColors;
  } else {
    colors = denscoverColorSchemes[nclasses] || denscoverColorSchemes[5];
    const values = denscoverData.features.map(f => parseFloat(f.properties[layerDefinitions.denscover.dataField]));
    breaks = calculateBreaks(values, nclasses, method, false, null);
  }

  const expr = createStepExpression(breaks, colors, layerDefinitions.denscover.dataField);
  ensureSource(layerDefinitions.denscover.sourceId, denscoverData);

  if (map.getLayer(layerDefinitions.denscover.layerId)) {
    map.setPaintProperty(layerDefinitions.denscover.layerId, 'fill-color', expr);
  } else {
    map.addLayer({
      id: layerDefinitions.denscover.layerId,
      type: 'fill',
      source: layerDefinitions.denscover.sourceId,
      paint: {
        'fill-color': expr,
        'fill-opacity': parseInt(document.getElementById('denscoverOpacity').value,10)/100
      }
    });
  }

  layerDefinitions.denscover.breaks = breaks;
  layerDefinitions.denscover.colors = colors;
  enabledLayers.denscover = true;
  document.getElementById('denscoverControls').style.display = 'block';
  updateLegend();
}

/**
 * loadDensCoverLayer()
 * Fetches the dasymmetric GeoJSON file and applies classification
 */
function loadDensCoverLayer() {
  fetch(layerDefinitions.denscover.url)
    .then(r => r.json())
    .then(gj => {
      denscoverData = gj;
      applyDensCoverClassification();
    })
    .catch(err => {
      console.error('Failed to load DENS_COVER:', err);
      alert('Error loading DENS_COVER geojson.');
    });
}

/**
 * loadPoipopLayer()
 * Loads the proportional symbols (circles) layer
 * 
 * ğŸ¨ RENDERING ORDER CONTROL
 * 
 * MapLibre GL renders circle features in the order they appear in the GeoJSON.
 * To ensure smaller circles always appear on top of larger ones, we fetch the
 * data, sort it by population (largest first), then add it to the map.
 * 
 * This sorting ensures:
 * - Large circles drawn first â†’ appear in back
 * - Small circles drawn last â†’ appear in front (on top)
 * - Better visibility of smaller municipalities
 * 
 * ğŸ“š BACKGROUND: Why Flannery Scaling?
 * 
 * When humans look at circles of different sizes, they underestimate
 * the size difference. For example, if one circle has 4x the area of
 * another, it doesn't LOOK 4x larger - it looks more like 2-3x larger.
 * 
 * James J. Flannery researched this since 1956 and found that using a power
 * of 0.57 (instead of 0.5 for true area scaling) makes circles appear
 * more proportional to their data values.
 * 
 * FORMULA: radius = (value / maxValue) ^ 0.57 Ã— maxRadius
 * 
 * Where:
 * - value = population for this feature
 * - maxValue = largest population across all years
 * - 0.57 = Flannery exponent for perceptual correction
 * - maxRadius = maximum circle size in pixels
 */
function loadPoipopLayer() {
  const def = layerDefinitions.poipop;
  
  // Fetch the GeoJSON data
  fetch(def.url)
    .then(r => r.json())
    .then(geojson => {
      // ============================================================
      // SORT FEATURES BY POPULATION SIZE (LARGEST FIRST)
      // ============================================================
      // This ensures smaller circles render on top of larger ones
      // MapLibre renders features in array order, so we sort descending
      // ============================================================
      
      geojson.features.sort((a, b) => {
        const valA = parseFloat(a.properties[def.dataField]) || 0;
        const valB = parseFloat(b.properties[def.dataField]) || 0;
        return valB - valA;  // Descending: largest first, smallest last
      });
      
      // Debug: Log first and last features to verify sorting
      console.log('Sorted proportional symbols by population (largest first)');
      console.log('First feature (largest):', geojson.features[0].properties[def.dataField]);
      console.log('Last feature (smallest):', geojson.features[geojson.features.length - 1].properties[def.dataField]);
      
      // Add sorted data as source
      ensureSource(def.sourceId, geojson);

      const maxR = parseInt(document.getElementById('maxRadius').value,10);
      const vL = def.maxValueApprox || 160000; // ğŸŒ Set the same number as in Line 390 (maximum population value based on the geojson population field values)
      const radiusExpr = ['*', ['^', ['/', ['get', def.dataField], vL], 0.57], maxR]; // ğŸ—ºï¸ You generally don't need to modify this function unless you want to experiment with different scaling methods

      if (!map.getLayer(def.layerId)) {
        map.addLayer({
          id: def.layerId,
          type: 'circle',
          source: def.sourceId,
          paint: {
            'circle-color': 'rgba(188,189,220,0.25)',  // ğŸŒ Change circle fill color (legend uses stroke only - see Lines ~1170 - 1183)
            'circle-radius': radiusExpr,
            'circle-opacity': parseInt(document.getElementById('poipopOpacity').value,10)/100,
            'circle-stroke-color': 'HotPink',          // ğŸŒï¸ Change circle outline color (also change legend Lines ~1170 - 1183 stroke="red")
            'circle-stroke-width': 0.9
          }
        });
      } else {
        map.setPaintProperty(def.layerId, 'circle-radius', radiusExpr);
        map.setPaintProperty(def.layerId, 'circle-opacity', parseInt(document.getElementById('poipopOpacity').value,10)/100);
      }

      enabledLayers.poipop = true;
      document.getElementById('poipopControls').style.display = 'block';
      updateLegend();
    })
    .catch(err => {
      console.error('Failed to load proportional symbols:', err);
      alert('Error loading proportional symbols GeoJSON.');
    });
}

/**
 * updatePoipopRadius()
 * Updates circle sizes when user adjusts the radius slider
 */
function updatePoipopRadius() {
  const def = layerDefinitions.poipop;
  if (!map.getLayer(def.layerId)) return;
  
  const maxR = parseInt(document.getElementById('maxRadius').value,10);
  const vL = def.maxValueApprox || 160000; // ğŸŒ Set the same number as in Lines 390 and 894 (maximum population value based on the geojson population field values)
  const radiusExpr = ['*', ['^', ['/', ['get', def.dataField], vL], 0.57], maxR]; // ğŸ—ºï¸ You generally don't need to modify this function unless you want to experiment with different scaling methods
  
  map.setPaintProperty(def.layerId, 'circle-radius', radiusExpr);
  updateLegend();
}

/**
 * loadContoursLayer()
 * Loads the population potential contour lines (isopleths)
 * 
 * Contours show areas of equal population potential, useful for
 * identifying population centers and their zones of influence.
 */
function loadContoursLayer() {
  const def = layerDefinitions.contours;
  ensureSource(def.sourceId, def.url);

  const widthExpr = ['case', ['==', ['get', 'ID'], 1], 3, 1.2];
  const color = '#9C4DEA';  // ğŸŒ Change contour line color (also change legend Lines ~1194-1200 stroke="#8B0000")

  if (!map.getLayer(def.layerId)) {
    map.addLayer({
      id: def.layerId,
      type: 'line',
      source: def.sourceId,
      paint: {
        'line-color': color,
        'line-width': widthExpr,
        'line-opacity': parseInt(document.getElementById('contoursOpacity').value,10)/100
      }
    });
  } else {
    map.setPaintProperty(def.layerId, 'line-width', widthExpr);
    map.setPaintProperty(def.layerId, 'line-opacity', parseInt(document.getElementById('contoursOpacity').value,10)/100);
  }

  enabledLayers.contours = true;
  document.getElementById('contoursControls').style.display = 'block';
  updateLegend();
}

/**
 * loadDotsLayer()
 * Loads the dot density map layer
 * 
 * ğŸ“š BACKGROUND:
 * Dot density maps use one dot to represent a fixed number of people
 * (e.g., 1 dot = 500 people). The visual density of dots shows
 * population concentration patterns.
 */
function loadDotsLayer() {
  const def = layerDefinitions.dots;
  ensureSource(def.sourceId, def.url);

  const dotSize = parseFloat(document.getElementById('dotSize').value);
  const opacity = parseInt(document.getElementById('dotsOpacity').value,10)/100;

  if (!map.getLayer(def.layerId)) {
    map.addLayer({
      id: def.layerId,
      type: 'circle',
      source: def.sourceId,
      paint: {
        'circle-color': '#9C4DEA',  // ğŸŒ Change dot color (also change legend Lines ~1207-1208 fill="#ff0000")
        'circle-radius': dotSize,
        'circle-opacity': opacity
      }
    });
  } else {
    map.setPaintProperty(def.layerId, 'circle-radius', dotSize);
    map.setPaintProperty(def.layerId, 'circle-opacity', opacity);
  }

  enabledLayers.dots = true;
  document.getElementById('dotsControls').style.display = 'block';
  updateLegend();
}

/**
 * loadBoundariesLayer()
 * Loads the municipal boundary lines
 * 
 * Boundaries provide geographic context by showing the official
 * administrative divisions.
 */
function loadBoundariesLayer() {
  const def = layerDefinitions.boundaries;
  ensureSource(def.sourceId, def.url);

  if (!map.getLayer(def.layerId)) {
    map.addLayer({
      id: def.layerId,
      type: 'line',
      source: def.sourceId,
      paint: {
        'line-color': '#bbbbbb',  // ğŸ—ºï¸ Change boundary line color (also change legend Line ~1216 stroke="#bbbbbb")
        'line-width': 1.5,
        'line-opacity': parseInt(document.getElementById('boundariesOpacity').value,10)/100
      }
    });
  } else {
    map.setPaintProperty(def.layerId, 'line-opacity', parseInt(document.getElementById('boundariesOpacity').value,10)/100);
  }

  enabledLayers.boundaries = true;
  document.getElementById('boundariesControls').style.display = 'block';
  updateLegend();
}

/**
 * removeLayer()
 * Removes a layer from the map when user unchecks it
 * 
 * @param {string} name - Name of the layer to remove
 */
function removeLayer(name) {
  const def = layerDefinitions[name];
  if (map.getLayer(def.layerId)) map.removeLayer(def.layerId);
  if (map.getSource(def.sourceId)) map.removeSource(def.sourceId);
  enabledLayers[name] = false;
  const c = document.getElementById(name + 'Controls');
  if (c) c.style.display = 'none';
  updateLegend();
}

// ============================================================
// 6. LEGEND GENERATION
// ============================================================
// Dynamically creates legend based on which layers are active

/* ğŸŒ MODIFY LEGEND TITLE AND TEXT */
function updateLegend() {
  const legend = document.getElementById('legend');
  let html = '';

  /* ğŸŒ Change the text below to customize your map title and credits */
  html += `
    <div class="legend-header">
      <div class="legend-map-title">THESSALIA POPULATION / Î Î›Î—Î˜Î¥Î£ÎœÎŸÎ£ Î˜Î•Î£Î£Î‘Î›Î™Î‘Î£</div>
      <div class="legend-author">
        <strong>Data source / Î Î·Î³Î® Î´ÎµÎ´Î¿Î¼Î­Î½Ï‰Î½:</strong> Hellenic Statistical Authority - Population data 2021 /  Î•Î›Î£Î¤Î‘Î¤ - Î”ÎµÎ´Î¿Î¼Î­Î½Î± Ï€Î»Î·Î¸Ï…ÏƒÎ¼Î¿Ï 2021<br>
        <strong>Produced by / Î”Î·Î¼Î¹Î¿Ï…ÏÎ³Î¯Î± Î±Ï€ÏŒ:</strong> Fytilis Nikolaos / Î¦Ï…Ï„Î¯Î»Î·Ï‚ ÎÎ¹ÎºÏŒÎ»Î±Î¿Ï‚<br> <!-- ğŸŒ Author name and surname -->
        <strong>Student ID / Î‘ÏÎ¹Î¸Î¼ÏŒÏ‚ Î¼Î·Ï„ÏÏÎ¿Ï…:</strong> rs21402<br> <!-- ğŸŒ Author ID -->
        National Technical University of Athens (NTUA) / Î•Î¸Î½Î¹ÎºÏŒ ÎœÎµÏ„ÏƒÏŒÎ²ÎµÎ¹Î¿ Î Î¿Î»Ï…Ï„ÎµÏ‡Î½ÎµÎ¯Î¿ (Î•ÎœÎ )<br>
        School of Rural, Surveying & Geoinformatics Engineering / Î£Î‘Î¤Îœ - ÎœÎ“<br>
        Cartography Laboratory - Î•ÏÎ³Î±ÏƒÏ„Î®ÏÎ¹Î¿ Î§Î±ÏÏ„Î¿Î³ÏÎ±Ï†Î¯Î±Ï‚<br>
        Thematic Cartography - Î˜ÎµÎ¼Î±Ï„Î¹ÎºÎ® Î§Î±ÏÏ„Î¿Î³ÏÎ±Ï†Î¯Î±<br>
	Academic Year / Î‘ÎºÎ±Î´Î·Î¼Î±ÏŠÎºÏŒ Î­Ï„Î¿Ï‚: 2025-2026
      </div>
    </div>
  `;

  // Choropleth map legend
  if (enabledLayers.popdens && layerDefinitions.popdens.breaks) {
    const breaks = layerDefinitions.popdens.breaks;
    const colors = layerDefinitions.popdens.colors;
    
    // ğŸ—ºï¸ Change "Choropleth map (people / kmÂ²)" to your preferred legend title
    html += `<div class="legend-title">Choropleth map (people / kmÂ²) / Î§Ï‰ÏÎ¿Ï€Î»Î·Î¸Î®Ï‚ Ï‡Î¬ÏÏ„Î·Ï‚ (Î¬Î½Î¸ÏÏ‰Ï€Î¿Î¹ / kmÂ²)</div>`;
    html += `<div class="legend-row"><div class="legend-color" style="background:${colors[0]}"></div><div>&lt; ${breaks[0]}</div></div>`;
    
    for (let i=0; i<breaks.length-1; i++){
      html += `<div class="legend-row"><div class="legend-color" style="background:${colors[i+1]}"></div><div>${breaks[i]} â€“ ${breaks[i+1]}</div></div>`;
    }
    
    html += `<div class="legend-row"><div class="legend-color" style="background:${colors[colors.length-1]}"></div><div>&gt; ${breaks[breaks.length-1]}</div></div>`;
    html += '<hr>';
  }

  // Dasymmetric map legend
  if (enabledLayers.denscover && layerDefinitions.denscover.breaks) {
    const breaks = layerDefinitions.denscover.breaks;
    const colors = layerDefinitions.denscover.colors;
    
    // ğŸ—ºï¸ Change "Dasymmetric map (people / kmÂ² by land cover zone)" to your preferred legend title
    html += `<div class="legend-title">Dasymmetric map (people / kmÂ² by land cover zone) / Î”Î±ÏƒÏ…Î¼ÎµÏ„ÏÎ¹ÎºÏŒÏ‚ Ï‡Î¬ÏÏ„Î·Ï‚ (Î¬Î½Î¸ÏÏ‰Ï€Î¿Î¹ / kmÂ² Î±Î½Î¬ Î¶ÏÎ½Î· ÎºÎ¬Î»Ï…ÏˆÎ·Ï‚ Î³Î·Ï‚)</div>`;
    html += `<div class="legend-row"><div class="legend-color" style="background:${colors[0]}"></div><div>&lt; ${breaks[0]}</div></div>`;
    
    for (let i=0; i<breaks.length-1; i++){
      html += `<div class="legend-row"><div class="legend-color" style="background:${colors[i+1]}"></div><div>${breaks[i]} â€“ ${breaks[i+1]}</div></div>`;
    }
    
    html += `<div class="legend-row"><div class="legend-color" style="background:${colors[colors.length-1]}"></div><div>&gt; ${breaks[breaks.length-1]}</div></div>`;
    html += '<hr>';
  }

  /* ğŸŒ MODIFY LEGEND CIRCLE SIZES */
  // Proportional symbols legend
  if (enabledLayers.poipop) {
    const maxR = parseInt(document.getElementById('maxRadius').value,10);
    const maxVal = layerDefinitions.poipop.maxValueApprox || 160000; // ğŸŒ Set the same number as in Lines 390 and 894 (maximum population value based on the geojson population field values)
    
    // ğŸŒ Change these values to match your data ranges
    const value1 = 3000;      // ğŸŒ Smallest circle (select an indicative value)
    const value2 = 15000;     // ğŸŒ Small-medium circle (select an indicative value)
    const value3 = 60000;     // ğŸŒ Medium-large circle (select an indicative value)
    const value4 = 160000;    // ğŸŒ Largest circle (select an indicative value)
    
    // Define the text labels that appear for each circle
    const label1 = "3 000"; // ğŸŒ Set the same value for the legend as in Line 1127
    const label2 = "15 000"; // ğŸŒ Set the same value for the legend as in Line 1128
    const label3 = "60 000"; // ğŸŒ Set the same value for the legend as in Line 1129
    const label4 = "160 000"; // ğŸŒ Set the same value for the legend as in Line 1130
    
    // Calculate circle sizes using Flannery formula
    // Use 100% of maxRadius for proper legend visibility
    const scaleFactor = 1.0;  // 100% of actual map size
    
    // Apply Flannery formula: radius = (value/max)^0.57 Ã— maxRadius Ã— scaleFactor
	// ğŸ—ºï¸ You generally don't need to modify this function unless you want to experiment with different scaling methods (as in Lines 895 and 935)
    const r1 = Math.pow(value1 / maxVal, 0.57) * maxR * scaleFactor;
    const r2 = Math.pow(value2 / maxVal, 0.57) * maxR * scaleFactor;
    const r3 = Math.pow(value3 / maxVal, 0.57) * maxR * scaleFactor;
    const r4 = Math.pow(value4 / maxVal, 0.57) * maxR * scaleFactor;
    
    // Calculate SVG dimensions and positions
    // All circles aligned at BOTTOM, centered horizontally
    const svgWidth = r4 * 2 + 60;    // Width based on largest circle + margins
    const svgHeight = r4 * 2 + 30;   // Height based on largest circle + space for labels
    const centerX = svgWidth / 2;    // Center horizontally
    const bottomY = svgHeight - 10;  // Bottom baseline position
    
    // Calculate Y positions - all circles sit on the same bottom baseline
    const cy1 = bottomY - r1;  // Smallest circle
    const cy2 = bottomY - r2;  // Medium circle
    const cy3 = bottomY - r3;  // Large circle
    const cy4 = bottomY - r4;  // Largest circle

    // ğŸ—º In the proportional symbols legend, you may change "Population (indicative values)" to your preferred legend title
    html += `<div class="legend-title">Population (indicative values) / Î Î»Î·Î¸Ï…ÏƒÎ¼ÏŒÏ‚ (ÎµÎ½Î´ÎµÎ¹ÎºÏ„Î¹ÎºÎ­Ï‚ Ï„Î¹Î¼Î­Ï‚)</div>`;
    html += `<div style="text-align:center"><svg width="${svgWidth}" height="${svgHeight}">`;
    
    // Draw FOUR NESTED circles from largest to smallest (back to front)
    // All circles aligned at BOTTOM, labels positioned ABOVE each circle
    // fill="none" means only red outline is visible (no color blending)
    
    // ğŸŒ Largest circle (80,000) - drawn first, appears in back (SAME COLOUR AS IN LINE 906)
    html += `<circle cx="${centerX}" cy="${cy4}" r="${r4}" fill="none" stroke="HotPink" stroke-width="1.5"/>`;
    html += `<text x="${centerX}" y="${cy4 - r4 - 5}" text-anchor="middle" font-size="11" fill="#333">${label4}</text>`;
    
    // ğŸŒ Large circle (40,000) (SAME COLOUR AS IN LINE 906)
    html += `<circle cx="${centerX}" cy="${cy3}" r="${r3}" fill="none" stroke="HotPink" stroke-width="1.5"/>`;
    html += `<text x="${centerX}" y="${cy3 - r3 - 5}" text-anchor="middle" font-size="11" fill="#333">${label3}</text>`;
    
    // ğŸŒ Medium circle (8,000) (SAME COLOUR AS IN LINE 906)
    html += `<circle cx="${centerX}" cy="${cy2}" r="${r2}" fill="none" stroke="HotPink" stroke-width="1.5"/>`;
    html += `<text x="${centerX}" y="${cy2 - r2 - 5}" text-anchor="middle" font-size="11" fill="#333">${label2}</text>`;
    
    // ğŸŒ Smallest circle (500) - drawn last, appears in front (SAME COLOUR AS IN LINE 906)
    html += `<circle cx="${centerX}" cy="${cy1}" r="${r1}" fill="none" stroke="HotPink" stroke-width="1.5"/>`;
    html += `<text x="${centerX}" y="${cy1 - r1 - 5}" text-anchor="middle" font-size="11" fill="#333">${label1}</text>`;
    
    // ğŸ—ºï¸ Change circle outline color by modifying stroke="red" above
    // Note: fill="none" means no fill, only red outline is shown
    // All circles share the same horizontal center but sit on bottom baseline
    // If you change stroke color here, also change map layer color at Lines ~903-906 'circle-stroke-color'
    
    html += `</svg></div><hr>`;
  }

  // Contours legend
  if (enabledLayers.contours) {
    // ğŸ—º Change "Population dynamic (2M & 4M)" to your preferred legend title
    html += `<div class="legend-title">Population dynamic (2M & 4M) / Î”Ï…Î½Î±Î¼Î¹ÎºÏŒ Ï€Î»Î·Î¸Ï…ÏƒÎ¼Î¿Ï (2Îœ &4Îœ)</div>`;
    html += `<div class="legend-row"><svg class="legend-line"><line x1="0" y1="7" x2="40" y2="7" stroke="#9C4DEA" stroke-width="3"/></svg><div>Primary / ÎšÏÏÎ¹ÎµÏ‚ (Id = 1)</div></div>`;
    html += `<div class="legend-row"><svg class="legend-line"><line x1="0" y1="7" x2="40" y2="7" stroke="#9C4DEA" stroke-width="1.2"/></svg><div>Secondary / Î”ÎµÏ…Ï„ÎµÏÎµÏÎ¿Ï…ÏƒÎµÏ‚ (Id = 2)</div></div>`;
    // ğŸŒ Change stroke="#8B0000" to modify contour line color in legend
    // Also change map layer color at Line ~953 const color = '#8B0000' (SAME COLOUR AS IN LINE 953)
    html += '<hr>';
  }

  // Dot map legend
  if (enabledLayers.dots) {
    // ğŸŒ Change "Population density" to your preferred legend title
    html += `<div class="legend-title">Population density / Î Ï…ÎºÎ½ÏŒÏ„Î·Ï„Î± Ï€Î»Î·Î¸Ï…ÏƒÎ¼Î¿Ï</div>`;
    html += `<div class="legend-row"><svg width="30" height="24"><circle cx="15" cy="12" r="${parseFloat(document.getElementById('dotSize').value)}" fill="#9C4DEA"/></svg><div>1 dot / ÎºÎ¿Ï…ÎºÎ¯Î´Î± = 500 people / Î¬Î½Î¸ÏÏ‰Ï€Î¿Î¹</div></div>`;
    // ğŸŒ Change fill="#ff0000" for dot color and "500 people" to match your data
    // Also change map layer color at Line ~998 'circle-color': '#ff0000' (SAME COLOUR AS IN LINE 998)
    html += '<hr>';
  }

  // Boundaries legend
  if (enabledLayers.boundaries) {
    html += `<div class="legend-row"><svg width="40" height="18"><line x1="0" y1="9" x2="40" y2="9" stroke="#bbbbbb" stroke-width="1"/></svg> <div> Municipal boundaries / ÎŒÏÎ¹Î± Î´Î®Î¼Ï‰Î½</div></div>`;
    // ğŸ—ºï¸ Change stroke="#bbbbbb" for boundary line color in legend
    // Also change map layer color at Line ~1030 'line-color': '#bbbbbb' (SAME COLOUR AS IN LINE 1030)
  }

  // Add resize hint at the bottom of legend
  if (html.length) {
    html += `<div style="text-align: right; font-size: 10px; color: #999; margin-top: 10px;">ğŸ’¡ Drag corner to resize / Î£ÏÏÎµÏ„Îµ Ï„Î·Î½ Î³Ï‰Î½Î¯Î± Î³Î¹Î± Î±Î»Î»Î±Î³Î® Î¼ÎµÎ³Î­Î¸Î¿Ï…Ï‚</div>`;
  }

  // Show or hide legend based on whether any layers are active
  if (html.length) {
    legend.innerHTML = html;
    legend.style.display = 'block';
  } else {
    legend.style.display = 'none';
  }
}

// ============================================================
// 7. EVENT LISTENERS
// ============================================================
// These functions respond to user interactions with the interface

/**
 * showHideControls()
 * Shows/hides layer control panels based on checkbox state
 */
function showHideControls() {
  Object.keys(enabledLayers).forEach(k => {
    const checkbox = document.getElementById(k + 'Toggle');
    const controls = document.getElementById(k + 'Controls');
    if (!controls) return;
    controls.style.display = checkbox.checked ? 'block' : 'none';
  });
}

// Choropleth layer toggle
document.getElementById('popdensToggle').addEventListener('change', (e) => {
  if (e.target.checked) { loadPopDensLayer(); } else { removeLayer('popdens'); }
});

// Choropleth classification method selector
document.getElementById('classificationMethod').addEventListener('change', () => {
  const method = document.getElementById('classificationMethod').value;
  const numClassesLabel = document.getElementById('numClassesLabel');
  const numClassesSelect = document.getElementById('numClasses');
  
  // Disable number of classes selector when using custom breaks
  if (method === 'custom') {
    numClassesSelect.disabled = true;
    numClassesLabel.style.opacity = '0.5';
  } else {
    numClassesSelect.disabled = false;
    numClassesLabel.style.opacity = '1';
  }
  
  if (enabledLayers.popdens) applyPopDensClassification();
});

// Choropleth number of classes selector
document.getElementById('numClasses').addEventListener('change', () => {
  if (enabledLayers.popdens) applyPopDensClassification();
});

// Choropleth opacity slider
document.getElementById('popdensOpacity').addEventListener('input', (e) => {
  document.getElementById('popdensOpacityLabel').textContent = e.target.value + '%';
  if (map.getLayer(layerDefinitions.popdens.layerId)) {
    map.setPaintProperty(layerDefinitions.popdens.layerId, 'fill-opacity', parseInt(e.target.value,10)/100);
  }
});

// Dasymmetric layer toggle
document.getElementById('denscoverToggle').addEventListener('change', (e) => {
  if (e.target.checked) { loadDensCoverLayer(); } else { removeLayer('denscover'); }
});

// Dasymmetric classification method selector
document.getElementById('denscoverClassificationMethod').addEventListener('change', () => {
  const method = document.getElementById('denscoverClassificationMethod').value;
  const numClassesLabel = document.getElementById('denscoverNumClassesLabel');
  const numClassesSelect = document.getElementById('denscoverNumClasses');
  
  if (method === 'custom') {
    numClassesSelect.disabled = true;
    numClassesLabel.style.opacity = '0.5';
  } else {
    numClassesSelect.disabled = false;
    numClassesLabel.style.opacity = '1';
  }
  
  if (enabledLayers.denscover) applyDensCoverClassification();
});

// Dasymmetric number of classes selector
document.getElementById('denscoverNumClasses').addEventListener('change', () => {
  if (enabledLayers.denscover) applyDensCoverClassification();
});

// Dasymmetric opacity slider
document.getElementById('denscoverOpacity').addEventListener('input', (e) => {
  document.getElementById('denscoverOpacityLabel').textContent = e.target.value + '%';
  if (map.getLayer(layerDefinitions.denscover.layerId)) {
    map.setPaintProperty(layerDefinitions.denscover.layerId, 'fill-opacity', parseInt(e.target.value,10)/100);
  }
});

// Proportional symbols layer toggle
document.getElementById('poipopToggle').addEventListener('change', (e) => {
  if (e.target.checked) { loadPoipopLayer(); } else { removeLayer('poipop'); }
});

// Proportional symbols radius slider
document.getElementById('maxRadius').addEventListener('input', (e) => {
  document.getElementById('maxRadiusLabel').textContent = e.target.value;
  updatePoipopRadius();
});

// Proportional symbols opacity slider
document.getElementById('poipopOpacity').addEventListener('input', (e) => {
  document.getElementById('poipopOpacityLabel').textContent = e.target.value + '%';
  if (map.getLayer(layerDefinitions.poipop.layerId)) {
    map.setPaintProperty(layerDefinitions.poipop.layerId, 'circle-opacity', parseInt(e.target.value,10)/100);
  }
});

// Contours layer toggle
document.getElementById('contoursToggle').addEventListener('change', (e) => {
  if (e.target.checked) { loadContoursLayer(); } else { removeLayer('contours'); }
});

// Contours opacity slider
document.getElementById('contoursOpacity').addEventListener('input', (e) => {
  document.getElementById('contoursOpacityLabel').textContent = e.target.value + '%';
  if (map.getLayer(layerDefinitions.contours.layerId)) {
    map.setPaintProperty(layerDefinitions.contours.layerId, 'line-opacity', parseInt(e.target.value,10)/100);
  }
});

// Dot map layer toggle
document.getElementById('dotsToggle').addEventListener('change', (e) => {
  if (e.target.checked) { loadDotsLayer(); } else { removeLayer('dots'); }
});

// Dot map size slider
document.getElementById('dotSize').addEventListener('input', (e) => {
  document.getElementById('dotSizeLabel').textContent = e.target.value;
  if (map.getLayer(layerDefinitions.dots.layerId)) {
    map.setPaintProperty(layerDefinitions.dots.layerId, 'circle-radius', parseFloat(e.target.value));
  }
});

// Dot map opacity slider
document.getElementById('dotsOpacity').addEventListener('input', (e) => {
  document.getElementById('dotsOpacityLabel').textContent = e.target.value + '%';
  if (map.getLayer(layerDefinitions.dots.layerId)) {
    map.setPaintProperty(layerDefinitions.dots.layerId, 'circle-opacity', parseInt(e.target.value,10)/100);
  }
});

// Boundaries layer toggle
document.getElementById('boundariesToggle').addEventListener('change', (e) => {
  if (e.target.checked) { loadBoundariesLayer(); } else { removeLayer('boundaries'); }
});

// Boundaries opacity slider
document.getElementById('boundariesOpacity').addEventListener('input', (e) => {
  document.getElementById('boundariesOpacityLabel').textContent = e.target.value + '%';
  if (map.getLayer(layerDefinitions.boundaries.layerId)) {
    map.setPaintProperty(layerDefinitions.boundaries.layerId, 'line-opacity', parseInt(e.target.value,10)/100);
  }
});

// Basemap switcher
document.getElementById('basemapSelect').addEventListener('change', (e) => {
  const style = e.target.value;
  const enabledSnapshot = {...enabledLayers};
  map.setStyle(style);
  
  map.once('styledata', () => {
    for (const key in enabledSnapshot) {
      if (enabledSnapshot[key]) {
        if (key === 'popdens') {
          if (popdensData) { applyPopDensClassification(); } else { loadPopDensLayer(); }
        } else if (key === 'denscover') {
          if (denscoverData) { applyDensCoverClassification(); } else { loadDensCoverLayer(); }
        } else if (key === 'poipop') { loadPoipopLayer();
        } else if (key === 'contours') { loadContoursLayer();
        } else if (key === 'dots') { loadDotsLayer();
        } else if (key === 'boundaries') { loadBoundariesLayer(); }
      }
    }
  });
});

// Initialize control panel visibility
showHideControls();

// Update legend when any control changes
const uiInputs = ['classificationMethod','numClasses','popdensOpacity','denscoverClassificationMethod','denscoverNumClasses','denscoverOpacity','maxRadius','poipopOpacity','contoursOpacity','dotSize','dotsOpacity','boundariesOpacity'];
uiInputs.forEach(id => {
  const el = document.getElementById(id);
  if (!el) return;
  el.addEventListener('input', () => { updateLegend(); });
});

// Update controls and legend when layer checkboxes change
['popdensToggle','denscoverToggle','poipopToggle','contoursToggle','dotsToggle','boundariesToggle'].forEach(id => {
  document.getElementById(id).addEventListener('change', () => {
    showHideControls();
    updateLegend();
  });
});

// Map load event (currently empty, but can be used for initialization)
map.on('load', () => {});

// Log initialization message
console.log('Thessalia Cartography Viewer - Ready');
console.log('Data files expected in "data/" folder');
console.log(layerDefinitions);

// ============================================================
// END OF JAVASCRIPT CODE
// ============================================================
</script>

<!-- ============================================================
     QUICK REFERENCE GUIDE
     ============================================================
     
     ğŸ“š WHAT YOU NEED TO MODIFY (ğŸŒ = MANDATORY, ğŸ—ºï¸ = OPTIONAL):
     
     1. MAP SETTINGS (Lines ~351-355):
        ğŸŒ center - [longitude, latitude] for your study area
        ğŸŒ zoom - Initial zoom level (8-12 typical for regions)
     
     2. DATA CONFIGURATION (Lines ~348-424):
        ğŸŒ All file paths (url) - Point to your GeoJSON files
        ğŸŒ All dataField values - Match your GeoJSON column names
        ğŸŒ maxValueApprox for poipop - Approximate max population
     
     3. COLOR SCHEMES (Lines ~426-507):
        ğŸ—ºï¸ colorSchemes - Colors for choropleth map
        ğŸ—ºï¸ denscoverColorSchemes - Colors for dasymmetric map
        ğŸ—ºï¸ customBreaks & customColors - Custom classification values
        
        IMPORTANT - How to change colors:
        - Colors are automatically used in BOTH the map AND the legend
        - Change colors in the colorSchemes object (Lines ~432-506)
        - The legend will automatically update with your new colors ONLY FOR THE CHOROPLETH AND DASYMETRIC MAPS
        - Use hex format: '#RRGGBB' (e.g., '#ff0000' = red)
        - Number of colors = Number of classes
        
        IMPORTANT - How to change custom breaks:
        - For Choropleth: Edit customBreaks (Line ~449) and customColors (Line ~450)
        - For Dasymmetric: Edit denscoverCustomBreaks (Line ~461) and denscoverCustomColors (Line ~462)
        - Rule: Number of colors MUST equal number of breaks + 1 (i.e. the total number of classes)
        - Example: 5 breaks = 6 colors (one for each range)
        - Legend automatically updates with your new breaks and colors
     
     4. LEGEND TITLE (Lines ~885-897):
        ğŸ—ºï¸ Main title text
        ğŸ—ºï¸ Data source information
        ğŸŒ Your name 
        ğŸŒ Student ID
     
     5. LAYER NAMES (in HTML controls section):
        ğŸ—ºï¸ Lines ~172-246 - Change layer names shown in left control panel
        - Change text inside <strong> tags
        - Example: Change "Population Density (Choropleth Map)" to your name
        - These are the names users see when selecting layers
     
     6. LEGEND TITLES (in JavaScript updateLegend function):
        ğŸ—ºï¸ Choropleth legend title (Line ~906)
        ğŸ—ºï¸ Dasymmetric legend title (Line ~921)
        ğŸ—ºï¸ Proportional symbols legend title (Line ~940)
        ğŸ—ºï¸ Contours legend title (Line ~964)
        ğŸ—ºï¸ Dots legend title (Line ~973)
        - These titles appear in the legend when layers are active
        - Change the text inside the quotes in the html += lines
     
     7. VISUALIZATION COLORS:
        ğŸŒ Proportional symbols color (Line ~747) - 'rgba(255,0,0,0.25)'
        ğŸŒ Contour line color (Line ~808) - '#8B0000'
        ğŸŒ Dot color (Line ~841) - '#ff0000' (red)
        ğŸŒï¸ Boundary color (Line ~864) - '#bbbbbb'
        
        NOTE: Circle colors in legend (Lines ~955-962) show only red outline
        with no fill (fill="none" stroke="red") for better visibility
     
     ============================================================
     
     ğŸ“– UNDERSTANDING THE APPLICATION:
     
     Layer Types Explained:
     
     1. **Choropleth Map** (Population Density)
        - Shows density by administrative area
        - Uses classification (equal interval, quantile, Jenks, custom)
        - Best for: Comparing municipalities
     
     2. **Dasymmetric Map** (Population by Land Cover)
        - Refines density using land cover data
        - More accurate than choropleth
        - Best for: Understanding population distribution patterns
     
     3. **Proportional Symbols** (Circles)
        - Circle size = total population
        - Uses Flannery scaling (exponent 0.57)
        - Features sorted by size: largest drawn first (back), smallest last (front)
        - This ensures smaller circles always visible on top when overlapping
        - Best for: Showing absolute magnitudes
     
     4. **Isopleths** (Contours)
        - Lines of equal population potential
        - Shows zones of influence
        - Best for: Identifying population centers
     
     5. **Dot Density Map**
        - Each dot = X people (e.g., 500)
        - Visual pattern shows concentration
        - Best for: General distribution patterns
     
     6. **Boundaries**
        - Administrative borders
        - Provides geographic context
        - Best for: Reference and orientation
     
     Classification Methods:
     
     - **Equal Interval**: Divides range into equal steps
       - Use when: Distribution is roughly uniform
       - Example: 0-20, 20-40, 40-60, 60-80, 80-100
     
     - **Quantile**: Equal number of features per class
       - Use when: Want to compare relative positions
       - Example: Each class contains 20% of municipalities
     
     - **Natural Breaks (Jenks)**: Maximizes between-class differences
       - Use when: Data has natural groupings
       - Example: Automatically finds "gaps" in data
     
     - **Custom**: You define the breaks
       - Use when: You have domain knowledge
       - Example: Break at important thresholds
     
     ============================================================
     
     ğŸ”— HELPFUL RESOURCES:
     
     - MapLibre GL Documentation: https://maplibre.org/maplibre-gl-js/docs/
     - GeoJSON Specification: https://geojson.org/
     - GeoJSON Validator: https://geojson.io/
     - Finding Coordinates: https://www.google.com/maps (right-click any location)
     - Color Picker: https://htmlcolorcodes.com/
     - ColorBrewer (cartographic colors): https://colorbrewer2.org/
     - Flannery Scaling Paper: https://doi.org/10.1080/00087041.1971.10471835
     
     ============================================================
     
     ğŸ’¡ TIPS FOR SUCCESS:
     
     1. Always work with a copy of your original files
     2. Test all GeoJSON files in https://geojson.io/ before using
     3. Use meaningful, consistent column names in your data
     4. Start with one layer, get it working, then add others
     5. Use browser console (F12) to debug issues
     6. Keep GeoJSON files under 5MB for good performance
     7. Use appropriate classification methods for your data
     8. Test with both Light and Dark basemaps
     9. Consider color blindness when choosing colors
     10. Document your data sources and methods
     
     ============================================================
     
     ğŸ¨ CUSTOMIZATION EXAMPLES:
     
     ğŸ”¢ HOW TO CHANGE COLORS:
     
     For Choropleth Map:
     1. Find colorSchemes object (Lines ~437-444)
     2. Change hex color values (e.g., '#ffcccc' to '#ccffcc')
     3. Save file and refresh browser
     4. Legend will automatically show new colors
     
     For Dasymmetric Map:
     1. Find denscoverColorSchemes object (Lines ~451-458)
     2. Change hex color values
     3. Save and refresh
     4. Legend updates automatically
     
     For Custom Classification Colors:
     1. Find customColors (Line ~450) or denscoverCustomColors (Line ~462)
     2. Change hex color values: ['#color1', '#color2', '#color3', ...]
     3. Remember: Number of colors = Number of breaks + 1
     4. Save and refresh
     
     ğŸ”¢ HOW TO CHANGE CUSTOM BREAKS:
     
     For Choropleth Map:
     1. Find customBreaks (Line ~449)
     2. Change values: [30, 75, 150, 300, 600]
     3. Find customColors (Line ~450)
     4. Ensure you have one more color than breaks
     5. Save and refresh
     6. Select "Custom intervals" in dropdown to see changes
     
     For Dasymmetric Map:
     1. Find denscoverCustomBreaks (Line ~461)
     2. Change values: [500, 1500, 3500, 6000, 8500]
     3. Find denscoverCustomColors (Line ~462)
     4. Ensure you have one more color than breaks
     5. Save and refresh
     6. Select "Custom intervals" in dropdown to see changes
     
     ğŸ“› HOW TO CHANGE LAYER NAMES:
     
     In Control Panel (what users click):
     1. Find HTML section Lines ~172-246
     2. Locate <strong>Layer Name</strong> for each layer
     3. Change text inside <strong> tags
     4. Example: <strong>Population Density (Choropleth Map)</strong>
        becomes: <strong>My Custom Name</strong>
     5. Save and refresh
     
     In Legend (titles shown when layer is active):
     1. Find updateLegend() function (starting Line ~883)
     2. Locate html += `<div class="legend-title">...</div>` lines
     3. Change text inside the quotes
     4. Examples:
        - Line ~906: Change "Choropleth map (people / kmÂ²)"
        - Line ~921: Change "Dasymmetric map (people / kmÂ² by land cover zone)"
        - Line ~940: Change "Population (indicative values)"
        - Line ~964: Change "Population dynamic (2M & 4M)"
        - Line ~973: Change "Population density"
     5. Save and refresh
     
     âš ï¸ IMPORTANT RULES:
     
     1. Color Arrays:
        - Must use square brackets: ['#color1', '#color2']
        - Must use quotes around each color: '#ff0000'
        - Colors separated by commas
        - Number of colors in custom = Number of breaks + 1
     
     2. Break Arrays:
        - Must be in ascending order: [10, 50, 100, 500]
        - Use square brackets: [value1, value2, value3]
        - No quotes needed for numbers
        - Values separated by commas
     
     3. Testing Changes:
        - Always save file before refreshing browser
        - Use F5 or Ctrl+R to refresh
        - Use Ctrl+Shift+R for hard refresh (clears cache)
        - Check browser console (F12) for error messages
     
     ============================================================
     
     ğŸ¨ CUSTOMIZATION IDEAS:
     
     Color Schemes:
     - Sequential: Light â†’ Dark (one hue, increasing intensity)
     - Diverging: Light â†’ Dark â†’ Light (two hues, middle = neutral)
     - Qualitative: Distinct colors (for categories, not quantities)
     
     Best Practices:
     - Use ColorBrewer for cartographically sound colors
     - Ensure sufficient contrast with basemap
     - Avoid red/green combinations
     - Limit to 5-7 classes for readability
     - Use darker colors for higher values (intuitive)
     
     Advanced Modifications:
     - Add popup on click showing municipality data
     - Implement search functionality for specific areas
     - Add data export functionality
     - Implement comparison view (side-by-side maps)
     
     ============================================================
-->
</body>
</html>




